<link rel="import"
      href="bower_components/polymer/polymer.html">
 <link rel="import" href="./imagine-time-slider-vertical.html">
   <link rel="import" href="./score_app/imagine-instance.html">

<script type="text/javascript" src="bower_components/interact.js/interact.min.js"></script>
<link rel='stylesheet' id='fonts.com-css'  href='https://fast.fonts.com/cssapi/fdd23a19-e66b-4f7a-b13d-626056555134.css?ver=165b296345e0a16cbf7f4ea4e41d8f2ff1aedcac' type='text/css' media='all' />

<dom-module id="imagine-puzzel">
 <link rel='import' href='theme.css' type='css'>
<!--
Planned:
main: #4CC0D0
mild: #BAE3EA

Communi:
main: #FFD979
mild: #FFF1C9

Sprawl: 
main: #E6215B
mild: #D7989B

Renew:
main: #3ABBA0
mild: #AEDAC0
-->
  <style>
imagine-puzzel, .imagine-puzzel {
    font-family: "Avenir LT W01 65 Medium", sans-serif;
  }
#speelveld {
   
    position: absolute;
    top: 0px;
    left: 110px;
    right: 0px;
    bottom: 0px;
}
#bord {
    border: solid 1px #3A3335;
    position: absolute;
    top: 115px;
    left: 150px;
    right: 170px;
    background-image: url('background.png');
-moz-box-shadow:    2px 2px 5px 0px #3A3335;
  -webkit-box-shadow: 2px 2px 5px 0px #3A3335;
  box-shadow:         2px 2px 5px 0px #3A3335;
    }
.kaartje {
    background: url('kaartje-neutraal.png') no-repeat;
    width: 136px;
    height: 105px;
    z-index: 2;
    position: absolute;
    opacity: 0.8;
    text-align: center;
    valign: middle;
    line-height: 90px;
}



.dropzone {
  background: #b0adae;
  border: dashed 4px transparent;
  border-radius: 4px;
  transition: background-color 0.3s;
}



.drop-target {
  background-color: var(--imagine-puzzel-mild);
  border-color: #fff;
  border-style: solid;
}


.drag-drop.can-drop {
background-image: var(--imagine-puzzel-kaartje);
 
  opacity: 1;
  color: #fcfcfc;
  font-family: "Avenir LT W01 85 Heavy", sans-serif;
}


@-ms-keyframes wiggle{0%{-ms-transform:rotate3d(0, 0, 1, 3deg);}50%{-ms-transform:rotate3d(0, 0, 1, -3deg);}100%{-ms-transform:rotate3d(0, 0, 1, 3deg);}}
@-moz-keyframes wiggle{0%{-moz-transform:rotate3d(0, 0, 1, 3deg));}50%{-moz-transform:rotate3d(0, 0, 1, -3deg);}100%{-moz-transform:rotate3d(0, 0, 1, 3deg);}}
@-webkit-keyframes wiggle{0%{-webkit-transform:rotate3d(0, 0, 1, 3deg));}50%{-webkit-transform:rotate3d(0, 0, 1, -3deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 3deg);}}
@keyframes wiggle{0%{transform:rotate3d(0, 0, 1, 3deg));}50%{transform:rotate3d(0, 0, 1, -3deg);}100%{transform:rotate3d(0, 0, 1, 3deg);}}

.wiggle{
-webkit-animation: wiggle .3s 100;
animation:wiggle .3s 100;

}
imagine-time-slider-vertical {
    position: absolute;
    top: 115px;
    right: 150px;
    height: calc(100% - 230px);
    
    -moz-box-shadow:    2px 4px 5px 0px #3A3335;
  -webkit-box-shadow: 2px 4px 5px 0px #3A3335;
  box-shadow:         2px 4px 5px 0px #3A3335;
}
.hide {
display:none;
}
#event-0{left:10%}
#event-1{left:18%}
#event-2{left:26%}
#event-3{left:34%}
#event-4{left:42%}
#event-5{left:50%}
#event-6{left:58%}
#event-7{left:66%}
#event-8{left:74%}
#event-9{left:82%}
#event-10{right:0}
#event-11{right:0;top:10%}
#event-12{right:0;top:20%}
#event-13{right:0;top:30%}
#event-14{right:0;top:40%}
#event-15{right:0;top:50%}
#event-16{right:0;top:60%}
#event-17{right:0;top:70%}
#event-18{right:0;top:80%}
#event-19{right:0;top:90%}
#event-20{left:10%;bottom:0}
#event-21{left:18%;bottom:0}
#event-22{left:26%;bottom:0}
#event-23{left:34%;bottom:0}
#event-24{left:42%;bottom:0}
#event-25{left:50%;bottom:0}
#event-26{left:58%;bottom:0}
#event-27{left:66%;bottom:0}
#event-28{left:74%;bottom:0}
#event-29{left:82%;bottom:0}
#event-30{left:0}
#event-31{left:0;top:10%}
#event-32{left:0;top:20%}
#event-33{left:0;top:30%}
#event-34{left:0;top:40%}
#event-35{left:0;top:50%}
#event-36{left:0;top:60%}
#event-37{left:0;top:70%}
#event-38{left:0;top:80%}
#event-39{left:0;top:90%}


#properties div {
    width: 100px;
    height: 100px;
    margin: 5.5px;
    border: solid 1px #3a3335;
}

#properties div.found {
background: var(--imagine-puzzel-mild)
}
#properties div.lost {
background: #625c5e;
}
imagine-time-slider-vertical {
--paper-slider-knob-color:var(--imagine-puzzel-main, #4CC0D0);
}

  </style>
  <template>
    <imagine-instance id="instance" team="Team A" scenario="Sprawville" score="[[score]]" kaartjes="{{kaartjes}}"></imagine-instance>

    <!-- local DOM for your element -->
   <div id="properties">
       <template  is="dom-repeat" items="{{eigenschappen}}">
        <div id="{{item.id}}" class$="{{item.visible}}" ></div>
       </template>   
    </div> 
   <div id="speelveld">       
    <canvas id="bord" class="dropzone" width="{{width}}" height="{{height}}">
    </canvas>
    <imagine-time-slider-vertical max="300" value="{{value}}" done="{{done}}" start="{{start}}" > </imagine-time-slider-vertical>
    <template id="kaartjesTemplate"  is="dom-repeat" items="{{kaartjes}}">
        <div id="{{createID(item._data.id)}}" class="kaartje draggable drag-drop" >{{item._data.name}}</div>
    </template>    
   </div>
  </template>
</dom-module>

<script>
  // register a new element called proto-element
  Polymer({    
    is: "imagine-puzzel",   
    properties: {
    done: {
        type: Boolean,
        value: false,        
        observer:  '_doneChanged',
        notify: true
    },
    value: {
        type: Number,
        value: 0
    },
    start: {
        type: Boolean,
        value: false,
        notify: true
    },
    kaartjes: {
        type: Array,
        
        observer:  '_kaartjesChanged',
        notify: true
      },
    team: {
        type: String,
        value: 'Team A'
    },    
      

    eigenschappen: {
        type: Array,
        value: function() {
            var e = [];
            for(var i = 0; i<10;i++){             
                e.push({id:'property-'+i,visible:Math.round(Math.random())?'found':'lost'})
            }
            return e;
        }
      }
      
    },
    behaviors: [      
    ],
    observers: [
    ],
    //Functie om een kaartje op het speelveld te leggen
    createID: function(i) {
        return 'event-'+i;
    },
    //Functie om een kaartje te selecteren
    selectKaartje: function(e) {
        var kaartje = e.currentTarget.id;
        if(this.setje.begin === null || this.setje.begin === kaartje) {
            this.setje.begin = kaartje;
            var kaartjes = document.getElementsByClassName('can-drop');
            for(var i = 0; i< kaartjes.length;i++){        
                kaartjes[i].classList.add('wiggle');
                e.currentTarget.classList.add('first');
            }
        }
        else if (this.setje.end === null) {
            this.setje.end = kaartje;
            var nieuw = true;
            var self = this;
            var item = null;
            this.verbindingen.forEach(function(e,i){
                if(e.begin == self.setje.begin && e.end ==self.setje.end) {
                    nieuw =false;
                    item = i;
                }
            });
            if(nieuw===!null) {
                //add setje to the list
                this.verbindingen.push({'begin':this.setje.begin,'end':kaartje})
            }
            else {
                //remove item from the list
                this.verbindingen.splice(item,1);
            }
            this.drawVerbindingen();
            this.setje = {'begin':null,'end':null};
        }
        else {
            console.warn('what happened here');
        }
        
        
    },
    //Functie om twee kaartjes te verbinden, of als ze al zijn verbonden
    //te verbreken
    drawVerbindingen: function() {
        //resetCanvas
        var canvas = document.getElementById('bord');
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        var cityMain = this.style.main;
        this.verbindingen.forEach(function(e,i) {
            var b = document.getElementById(e.begin);
            var end = document.getElementById(e.end);
            var endPoint = [parseFloat(end.attributes['data-x'].value) - 133,parseFloat(end.attributes['data-y'].value) - 30]
            var beginPoint = [parseFloat(b.attributes['data-x'].value) - 35,parseFloat(b.attributes['data-y'].value) - 98]
            context.beginPath();
            context.moveTo(beginPoint[0],beginPoint[1]);
            context.lineTo(endPoint[0],endPoint[1]);
            context.lineWidth = 5;            
            context.strokeStyle = 'white';
            context.lineCap = 'round';
             context.stroke();
              context.beginPath();
            context.moveTo(beginPoint[0],beginPoint[1]);
            context.lineTo(endPoint[0],endPoint[1]);
            context.lineWidth = 1;            
            context.strokeStyle = 'rgba(127, 133, 134, 0.8)';
            
            context.lineCap = 'round';
            context.stroke();
        });
        
        //this.stopWiebelen();
    },
    stopWiebelen: function(){
        this.setje = {'begin':null,'end':null};
        var kaartjes = document.getElementsByClassName('can-drop');
        for(var i = 0; i< kaartjes.length;i++){            
            kaartjes[i].classList.remove('wiggle');
            kaartjes[i].classList.remove('first')
        }
            
                
               /* self.first = false;
                if(e.currentTarget.classList.contains('can-drop')) {
                    var kaartjes = document.getElementsByClassName('can-drop');
                    console.log('can-drop',e);
                    if(kaartjes[0].classList.contains('wiggle')&&!e.currentTarget.classList.contains('first') ){
                        var end = [parseFloat(e.currentTarget.attributes['data-x'].value) - 140,parseFloat(e.currentTarget.attributes['data-y'].value) - 20]
                        var first = document.getElementsByClassName('first');
                        var begin = [parseFloat(first[0].attributes['data-x'].value) - 36,parseFloat(first[0].attributes['data-y'].value) - 88]
                    
                        var canvas = document.getElementById('bord');
                        var context = canvas.getContext('2d');

                        context.beginPath();
                        context.moveTo(begin[0],begin[1]);
                        context.lineTo(end[0],end[1]);
                        context.lineWidth = 5;
                        context.strokeStyle = '#ff0000';
                        context.lineCap = 'round';
                        context.stroke();
                    }
                    for(var i = 0; i< kaartjes.length;i++){
                    
                        kaartjes[i].classList.remove('wiggle');
                        kaartjes[i].classList.remove('first')
                    }
                }*/
    },
    //Functie om alles te resetten en naar het scorebord te gaan
    
    
    
    //hulpfunctie om de overige kaartjes te verwijderen    
    _removeUnused: function() {
        //
        this.verbinden =true;
        this.speelkaarten = [];
        var allekaartjes  = document.getElementsByClassName('kaartje');
        //verwijder de kaartjes die niet op het speelbord liggen
        for(var i = 0; i< allekaartjes.length;i++){
            if(!allekaartjes[i].classList.contains('dropped'))
                allekaartjes[i].classList.add('hide');
            else this.speelkaarten.push(allekaartjes[i].id)
        }         
    },    
    _kaartjesChanged: function(){
        if(this.beginSpel && this.kaartjes.length > 0) {
            for(var i = 0; i<this.kaartjes.length;i++){
                this.kaartjes[i].data('x','').data('y','').sync();
          }
          console.log('reset kaartjes')
          this.beginSpel = false;
          }
    },
    _doneChanged: function(){
        
        //Als de tijd verstreken is gaan we over op het verbinden van de kaartjes
        if(this.done&& !this.verbinden) {            
            this._removeUnused();
          
            var self = this;
            interact('.draggable')
                .draggable({enabled:false})
                //Als het eerste kaartje wordt aangeraakt, gaan ze allemaal wiebelen tot dat 
                //of hij weer wordt losgelaten
                //of een ander kaartje wordt aangeraakt
                .on('down',function(e){    
                    self.selectKaartje(e);
                   
                });
            this.value = 0;
        }
        else if(this.done&&this.verbinden) {
            this.verbinden = false;
            show3D();
        }
    },
    ready: function() {        
        this.beginSpel = true;  //boolean to make sure that we have started a new game
        this.speelkaarten = []; //Array with the chosen cards (empty at start)
        this.verbindingen = []; //Array with the connected cards (empty at start)
        this.setje = {'begin':null,'end':null}; //Helper object to conenct kaartjes (empty at start)
        this.done= false; //
        this.counter = 0;        
        this.first = false;
        this.verbinden = false;
        this.value=0;
        this.zindex = 1;
        var self = this;
        var w =  (window.innerWidth > 0) ? window.innerWidth : screen.width;
        this.width=w-460;
        var h =  (window.innerHeight > 0) ? window.innerHeight : screen.height;
        this.height=h-230;
        var angle = 0;
        // target elements with the "draggable" class
        interact('.draggable')
            .draggable({
                // enable inertial throwing
                inertia: true,
                // keep the element within the area of it's parent
                restrict: {
                    restriction: "parent",
                    endOnly: true,
                    elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                },
                // call this function on every dragmove event
                onmove: dragMoveListener               
            }) 
            .on('down',function(e) {
              e.target.style.zIndex = self.zindex++
            })
            .on('up',function(e){              
                //truukje om te zorgen dat je zonder multitouch wel kan werken
                if(e.shiftKey) return true;
                else self.stopWiebelen();
           
            })
   
        function dragMoveListener (event) {
            var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                x = (parseFloat(target.getAttribute('data-x')) || event.target.offsetLeft) + event.dx,
                y = (parseFloat(target.getAttribute('data-y')) || event.target.offsetTop) + event.dy;    
            target.style.left = x+'px';
            target.style.top = y+'px';
            // update the position attributes
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        }

        window.dragMoveListener = dragMoveListener;
        
        interact('.dropzone').dropzone({
            // only accept elements matching this CSS selector
            accept: '.kaartje',
            // Require a 75% element overlap for a drop to be possible
            overlap: 0.75,
            // listen for drop related events:
            ondropactivate: function (event) {
                // add active dropzone feedback
                event.target.classList.add('drop-active');
            },
            ondragenter: function (event) {                
                if(self.counter>19) return false;
                
                var draggableElement = event.relatedTarget,
                    dropzoneElement = event.target;
                // feedback the possibility of a drop
                dropzoneElement.classList.add('drop-target');
                draggableElement.classList.add('can-drop');
            },
            ondragleave: function (event) {
                if(event.relatedTarget.classList.contains('dropped')) {
                    //formerly dropped item, remove drom the counter
                     event.relatedTarget.classList.remove('dropped');
                     self.counter--;
                     
                     //Set the X&Y to '' and sync
                     var item = self.kaartjes[event.relatedTarget.id.split('-')[1]];
                     item.data('x','').data('y','').sync();
                }
                // remove the drop feedback style
                event.target.classList.remove('drop-target');
                event.relatedTarget.classList.remove('can-drop');
            },
            ondrop: function (event) {   
                //We're at 20 kaartjes, no more are allowed (unless it is a currently dropepd one)
                if(self.counter>19&&!event.relatedTarget.classList.contains('dropped')) {
                    return false;
                }
                
                //Mark the kaartje as dropped and increase the counter
                event.relatedTarget.classList.add('dropped');
                self.counter++;
                
                //calculate the X and Y score
                var kaartjeX = (event.relatedTarget.offsetLeft -150 + 68 - 1)/event.target.width*100;
                var kaartjeY = (event.target.height - (event.relatedTarget.offsetTop -110 + 53 - 1))/event.target.height *50+50;
                
                //TODO: is dit niet buggy?? 
                var item = self.kaartjes[event.relatedTarget.id.split('-')[1]];
                
                //Set the X&Y score per kaartje and sync using cow.
                item.data('x',kaartjeX).data('y',kaartjeY).sync();
               
                
            },
            ondropdeactivate: function (event) {
                //Canvas isn't a droptarget anymore; clean up
                event.target.classList.remove('drop-active');
                event.target.classList.remove('drop-target');
            }
        });   
    }
  });
</script>