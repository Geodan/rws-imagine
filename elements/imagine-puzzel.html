
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="./imagine-time-slider-vertical.html">
<link rel="import" href="./imagine-instance.html">

  
<script type="text/javascript" src="../bower_components/interact.js/interact.min.js"></script>
<link rel='stylesheet' id='fonts.com-css' href='https://fast.fonts.com/cssapi/fdd23a19-e66b-4f7a-b13d-626056555134.css?ver=165b296345e0a16cbf7f4ea4e41d8f2ff1aedcac' type='text/css' media='all' />

<dom-module id="imagine-puzzel">
 <link rel='import' href='../style/theme.css' type='css'>
  <style>
paper-dialog {
  max-width: 50%;
      
}

  *{ 
  -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    }
  .stamped {
    background: url('../style/stamp.png') no-repeat;
    background-position-x: center;
    background-position-y: center;
  }
  .kaartjeText {
      position: inherit;
    top: 10px;
    left: 15px;
    bottom: 10px;
    right: 15px;
        align-items: center;
    display: flex;
}
  
.background{
float: left;
padding: 10px;
}
imagine-puzzel, .imagine-puzzel {
    font-family: "Avenir LT W01 65 Medium", sans-serif;
  }
#speelveld {

    position: absolute;
    top: 0px;
    left: 110px;
    right: 0px;
    bottom: 0px;
}
#bord {
    
    position: absolute;
    top: 115px;
    left: 150px;
    right: 260px;
    background-image: url('../style/background.png');
-moz-box-shadow:    2px 2px 5px 0px #3A3335;
  -webkit-box-shadow: 2px 2px 5px 0px #3A3335;
  box-shadow:         2px 2px 5px 0px #3A3335;
    }
.kaartje {
    background: url('../style/nkaartje-neutraal.png') no-repeat;
    width: 151px;
    height: 120px;
    z-index: 2;
    position: absolute;
    opacity: 0.8;
    text-align: center;
    valign: middle;
    font-size: 10px;
}



.dropzone {
  background: #b0adae;
  border: dashed 4px transparent;
  border-radius: 4px;
  transition: background-color 0.3s;
}



.drop-target {
  background-color: var(--imagine-puzzel-mild);
  border-color: #fff;
  border-style: solid;
}


.drag-drop.can-drop {
background-image: var(--imagine-puzzel-kaartje);

  opacity: 1;
  color: #fcfcfc;
  font-family: "Avenir LT W01 85 Heavy", sans-serif;
}


@-ms-keyframes wiggle{0%{-ms-transform:rotate3d(0, 0, 1, 3deg);}50%{-ms-transform:rotate3d(0, 0, 1, -3deg);}100%{-ms-transform:rotate3d(0, 0, 1, 3deg);}}
@-moz-keyframes wiggle{0%{-moz-transform:rotate3d(0, 0, 1, 3deg));}50%{-moz-transform:rotate3d(0, 0, 1, -3deg);}100%{-moz-transform:rotate3d(0, 0, 1, 3deg);}}
@-webkit-keyframes wiggle{0%{-webkit-transform:rotate3d(0, 0, 1, 3deg));}50%{-webkit-transform:rotate3d(0, 0, 1, -3deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 3deg);}}
@keyframes wiggle{0%{transform:rotate3d(0, 0, 1, 3deg));}50%{transform:rotate3d(0, 0, 1, -3deg);}100%{transform:rotate3d(0, 0, 1, 3deg);}}

.wiggle{
-webkit-animation: wiggle .3s 100;
animation:wiggle .3s 100;

}
imagine-time-slider-vertical {
    position: absolute;
    top: 115px;
    right: 210px;
    height: calc(100% - 240px);

  /*  -moz-box-shadow:    2px 4px 5px 0px #3A3335;
  -webkit-box-shadow: 2px 4px 5px 0px #3A3335;
  box-shadow:         2px 4px 5px 0px #3A3335;*/
}
.hide {
display:none;
}
#event-0{left:10%}
#event-1{left:18%}
#event-2{left:26%}
#event-3{left:34%}
#event-4{left:42%}
#event-5{left:50%}
#event-6{left:58%}
#event-7{left:66%}
#event-8{left:74%}
#event-9{left:82%}
#event-10{right:0}
#event-11{right:0;top:10%}
#event-12{right:0;top:20%}
#event-13{right:0;top:30%}
#event-14{right:0;top:40%}
#event-15{right:0;top:50%}
#event-16{right:0;top:60%}
#event-17{right:0;top:70%}
#event-18{right:0;top:80%}
#event-19{right:0;top:90%}
#event-20{left:10%;bottom:0}
#event-21{left:18%;bottom:0}
#event-22{left:26%;bottom:0}
#event-23{left:34%;bottom:0}
#event-24{left:42%;bottom:0}
#event-25{left:50%;bottom:0}
#event-26{left:58%;bottom:0}
#event-27{left:66%;bottom:0}
#event-28{left:74%;bottom:0}
#event-29{left:82%;bottom:0}
#event-30{left:0}
#event-31{left:0;top:10%}
#event-32{left:0;top:20%}
#event-33{left:0;top:30%}
#event-34{left:0;top:40%}
#event-35{left:0;top:50%}
#event-36{left:0;top:60%}
#event-37{left:0;top:70%}
#event-38{left:0;top:80%}
#event-39{left:0;top:90%}


#properties div {
    width: 100px;
    height: 100px;
    margin: 5.5px;
    border: solid 1px #3a3335;
}

#properties div.found {
background: var(--imagine-puzzel-mild)
}
#properties div.lost {
background: #625c5e;
}
:host[scenario=communicity] imagine-time-slider-vertical{
--paper-slider-knob-color:#FFD979;
}
:host[scenario=sprawlville] imagine-time-slider-vertical {
--paper-slider-knob-color:#E6215B;
}
:host[scenario=renewabad] imagine-time-slider-vertical {
--paper-slider-knob-color:#3ABBA0;
}
:host[scenario=planopolis] imagine-time-slider-vertical {
--paper-slider-knob-color:#4CC0D0;
}

  </style>
  <template>
  
    <imagine-instance id="instance"  core="{{core}}" team="{{team}}" scenario="{{scenario}}" score="[[score]]" kaartjes="{{kaartjes}}" reset=true ></imagine-instance>
    
    <!-- local DOM for your element -->
   <div id="properties" oncontextmenu="return false">
       <template  is="dom-repeat" items="{{eigenschappen}}">
        <div id="{{item.id}}" class$="{{item.visible}}" on-down="eigenschapDown" on-up="eigenschapUp"></div>
       </template>
    </div>
   <div id="speelveld" oncontextmenu="return false">
  
    <canvas id="bord" class="dropzone" width="{{width}}" height="{{height}}" oncontextmenu="return false"></canvas>
    <imagine-time-slider-vertical text="{{text}}" max="300" value="{{sliderValue}}" done="{{done}}" start="{{start}}" > </imagine-time-slider-vertical>
    <template id="kaartjesTemplate"  is="dom-repeat" items="{{kaartjes}}">
        <div id="{{createID(item._data.id)}}" class="kaartje draggable drag-drop" ><span class="kaartjeText">{{item._data.name}}</span></div>
    </template>
    
   </div>
   <paper-dialog id="eigenschapScherm"><p></p></paper-dialog>
  </template>
</dom-module>

<script>
  // register a new element called proto-element
  Polymer({
    is: "imagine-puzzel",
    properties: { 
    core: {
        type: Object,
    },
    team: {
        type: String,
        value: 'Team A'
    },
    scenario: {
        type: String,
        observer:  '_scenarioChanged',
        value: 'Sprawville'
    },
    eigenschappen: {
        type: Array,
        value: function() {
            var e = [{id:"property-	0	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Er is sprake van fossiele, dure brandstof en  een centraal bestuur	 ",textSprawlville:"	Er is sprake van fossiele, goedkope brandstof en een decentraal bestuur	 ",textRenewabad:"	Er is sprake van alternatieve dure brandstof en een centraal bestuur	 ",textCommunicity:"	Er is sprake van alternatieve, goedkope brandstof en een decentraal bestuur	 "},
{id:"property-	1	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Stadscentrum is groot, autovrij en kent veel hoogbouw. Daaromheen liggen grote leefgebieden die ten opzichte van elkaar uniform zijn gepland en opgebouwd.	 ",textSprawlville:"	Stadscentrum kent een normaal gebleven omvang. Daaromheen vindt men een keur aan grote, onderling verschillende leefgebieden, gescheiden door rommelige, vaak onafgemaakte tussengebieden.	 ",textRenewabad:"	Hier bestaat nauwelijks een stadscentrum. Eerder vindt men er een geordende verzameling van kleinere, door veel groen gescheiden, uniforme woongebieden met elk een vast eigen centrum en voorzieningen (polycentrisch).  	 ",textCommunicity:"	Hier bestaat nauwelijks een stadscentrum, doch slechts rondtrekkende, mobiele centra (markten).  Kenmerkend is een bonte verzameling van kleinere woongebieden met elk een eigen voedselvoorziening, energie voorziening (soms kernenergie) en karakter.  	 "},
{id:"property-	2	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Het landschap wordt gekenmerkt door twee soorten wegen: de oudere, goed onderhouden wegen en de nieuwere, smallere wegen, waarop zich zelfrijdende voertuigen in kolonnes bewegen, gestuurd door sensoren in de wegkant. 	 ",textSprawlville:"	Het landschap wordt gekenmerkt door vele soorten wegen, van smal tot zeer breed, gericht op zelf bestuurde voertuigen die dagelijks vele uren in de file staan. Grote parkeertorens houden auto's zoveel mogelijk langs de rand van de stad. Alleen elektrisch verkeer komt nog in de binnenstad.	 ",textRenewabad:"	Het landschap wordt gekenmerkt door smalle, nieuwe wegen voor elektrische auto's en bovengrondse fietstunnels, waarin de fietser de wind altijd mee heeft. Drukte en files bestaan hier niet meer door slim rekening-rijden per tijdzone.	 ",textCommunicity:"	Het landschap wordt gekenmerkt door versmalde, oude wegen met kas-tuinbouw langs de wegrand waar eerst nog asfalt lag. Wegen worden bevolkt door een bonte stoet soorten voertuigen op biomassa of andere alternatieve brandstoffen. Files worden voorkomen door eigen on-board sensors. 	 "},
{id:"property-	3	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Het treinen-netwerk is intact gebleven, maar de intensiteit is sterk toegenomen. 	 ",textSprawlville:"	Het treinen-netwerk is intact gebleven, zonder veel wijzigingen.  	 ",textRenewabad:"	Het treinen-netwerk is sterk gegroeid. Er bestaan gedeelde rails systemen voor Ultra HSL, HSL, Intercity, boemel, metro en tram. 	 ",textCommunicity:"	Het treinen-netwerk is intact gebleven, maar de intensiteit is sterk afgenomen. Veel verkeer tussen leefgebieden is niet meer nodig.	 "},
{id:"property-	4	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	In de stad vinden we een fijnmazig netwerk van autobanen, fietspaden en wandelroutes. Vernieuwd en goed onderhouden. De zelfrijdende auto's zorgen ervoor dat er nauwelijks file ontstaat.	 ",textSprawlville:"	In de stad vinden we een grofmazig, maar uitgebreid netwerk van betonnen autobanen, fly-overs, particuliere tolroutes, fietspaden en stroken. Onderhoud daaraan maakt de files dagelijks nog erger dan anders. 	 ",textRenewabad:"	In de leefgebieden vinden we een fijnmazig netwerk van lanes en andere big data gestuurde, persoonlijke mobiliteits-voorzieningen:  smalle wegen (autorijden in de gemeenschap is not done), brede wandel- en fietspaden, e-bike tracees, lopende banden en airpods.	 ",textCommunicity:"	In de leefgebieden vinden we oudere betonnen straten en stroken. Het onderhoud daarvan is matig en verschilt per leefgebied. In de winter strooit niemand. 	 "},
{id:"property-	5	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	De ringwegen zijn er nog wel, maar zijn thans ondertunneld, met een naadloze aansluiting op distributiecentra aan de rand van de stad.	 ",textSprawlville:"	De ringwegen zijn er nog en zijn breder en drukker dan ooit. Het verkeer de stad-in en het verkeer de stad-uit strijden om schaarse time/space slots.	 ",textRenewabad:"	De ringwegen zijn hier afgebroken en langzaam helemaal verdwenen.	 ",textCommunicity:"	De ringwegen zijn hier langzaam in onbruik geraakt en door andere activiteiten  - vaak voedsel- en handelsgerelateerd - overgenomen.	 "},
{id:"property-	6	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	De havenfunctie is gegroeid en kent tal van distributiecentra aan de kade met veel bulkvaart (graan e.d.).	 ",textSprawlville:"	De havenfunctie is gegroeid en kent veel tankopslag voor de drukke tankvaart (vloeibaar, chemisch).	 ",textRenewabad:"	De havenfunctie is niet gegroeid en is ook veranderd. Tankopslag is verdwenen ten gunste van solar energy centres.	 ",textCommunicity:"	De havenfunctie is verkleind ten gunste van bewoning en recreatie op het water. Elke leefgemeenschap heeft aanlegsteigers voor handel via water.	 "},
{id:"property-	7	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Fijnmazige distributie-centra bevoorraden de leefgebieden volgens het last mile principe. 	 ",textSprawlville:"	Vrachtwagens en bestelauto's kruisen door alle woongebieden. 	 ",textRenewabad:"	Fijnmazige distributie-regels, gegenereerd uit big data, verbinden kanalen en vaarten in de stad, via drones door de lucht en via buizen ondergronds of bots bovengronds.	 ",textCommunicity:"	Er is nauwelijks distributie nodig. Men is zelfvoorzienend.	 "},
{id:"property-	8	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Het OV is sterk uitgebreid en rijdt hoogfrequent door de hele stad	 ",textSprawlville:"	Het OV is niet uitgebreid, terwijl de stad wel groeit, met achtergebleven gebieden als gevolg.	 ",textRenewabad:"	Het OV is de standaard manier van vervoer. Het bestaat dan ook in vele soorten, die op maat kunnen worden gecombineerd.	 ",textCommunicity:"	Er is nauwelijks gebruik van het OV. Daarom is dit sterk ingekrompen.	 "},
{id:"property-	9	 ",visible:Math.round(Math.random())?"found":"lost",textPlanopolis:"	Er rijden standaard auto's, vaak klein, zelfrijdend en veel elektrisch.	 ",textSprawlville:"	Er rijden standaard auto's, groot en klein, elektrisch, hybride, status-auto's en werkauto's.	 ",textRenewabad:"	Er rijden weinig auto's en degene die er rijden zijn groen, gedeeld en intelligent.	 ",textCommunicity:"	Er rijden veel soorten gemotoriseerd vervoer op alternatieve, goedkope brandstoffen. Soms ook vliegend.	 "}

]
            return e;
        }
      }

    },
    behaviors: [
    ],
    observers: [
        '_doneChanged(done)',
        '_kaartjesChanged(kaartjes)'
    ],
    //Functie om een kaartje op het speelveld te leggen
    createID: function(i) {
        return 'event-'+i;
    },
    eigenschapDown: function(e) {
        if(e.target.classList.contains('found')){
        var text = '';
        switch(this.scenario) {
            case 'communicity':
            text = e.model.item.textCommunicity;
            break;
            case 'sprawlville':
            text = e.model.item.textSprawlville;
            break;
            case 'renewabad':
            text = e.model.item.textRenewabad;
            break;
            case 'planopolis':
            text = e.model.item.textPlanopolis;
            break;
            
        }
        
        var el = document.getElementById('eigenschapScherm');
        el.childNodes[1].innerHTML = text;
        el.open();
        }
    },
    eigenschapUp: function(e) {
        var el = document.getElementById('eigenschapScherm');
        el.close();
    },
    
    _scenarioChanged: function(){
        var s = this.scenario.toLowerCase();
        switch(s) {
            case 'sprawlville':
                this.customStyle['--imagine-puzzel-main'] = '#E6215B';
                this.customStyle['--paper-slider-knob-color'] = '#E6215B';
                this.customStyle['--imagine-puzzel-mild'] = '#f599a3';
                this.customStyle['--imagine-puzzel-kaartje']= "url('./style/nkaartje-sprawl.png')";
                this.updateStyles();
                break;
            case 'communicity':
                this.customStyle['--imagine-puzzel-main'] = '#FFD979';
                this.customStyle['--paper-slider-knob-color'] = '#FFD979';
                this.customStyle['--imagine-puzzel-mild'] = '#FFF1C9';
                this.customStyle['--imagine-puzzel-kaartje']= "url('./style/nkaartje-communi.png')";
                this.updateStyles();
                break;
            case 'renewabad':
                this.customStyle['--imagine-puzzel-main'] = "#3ABBA0";
                this.customStyle['--paper-slider-knob-color'] = '#3ABBA0';
                this.customStyle['--imagine-puzzel-mild'] = "#AEDAC0";
                this.customStyle['--imagine-puzzel-kaartje']= "url('./style/nkaartje-renew.png')";
                this.updateStyles();
                break;
            case 'planopolis':
                this.customStyle['--imagine-puzzel-main'] = "#4CC0D0";
                this.customStyle['--paper-slider-knob-color'] = '#4CC0D0';
                this.customStyle['--imagine-puzzel-mild'] = "#BAE3EA";
                this.customStyle['--imagine-puzzel-kaartje']= "url('./style/nkaartje-plan.png')";
                this.updateStyles();
                break;

        }
    },
    //Functie om een kaartje te selecteren
    selectKaartje: function(e) {
        console.log(this.verbindingen);
        //TODO: check de volgorde van de link en klap evt om
        var kaartje = {id:e.currentTarget.id.split('-')[1],x:e.currentTarget.attributes['data-x'].value}
        if(this.setje.begin === null || this.setje.begin.id === kaartje.id) {
            this.setje.begin = kaartje;
            var kaartjes = document.getElementsByClassName('can-drop');
            for(var i = 0; i< kaartjes.length;i++){
                kaartjes[i].classList.add('wiggle');


            }
            e.currentTarget.classList.remove('wiggle');
        }
        else if (this.setje.end === null) {   
            //SWAP!
            
            if(parseInt(kaartje.id) < parseInt(this.setje.begin.id)) {
                this.setje.end = {id:this.setje.begin.id,x:this.setje.begin.x};
                this.setje.begin = kaartje;
            }        
            else {
                this.setje.end = kaartje;
            }
            
            var nieuw = true;
            var self = this;
            var item = null;
            var instance = document.getElementById('instance');
            this.verbindingen.forEach(function(e,i){
                //check if the verbinding already exists
                if(e.begin == self.setje.begin.id && e.end ==self.setje.end.id) {
                    nieuw =false;
                    item = i;
                }
            });
            if(nieuw===!null) {
                //add setje to the list
                if(this.verbindingen.length > 9) return false;
                this.verbindingen.push({'begin':this.setje.begin.id,'end':this.setje.end.id})
                instance.createLink(this.setje.begin.id,this.setje.end.id);
            }
            else {
                //remove item from the list
                this.verbindingen.splice(item,1);
                instance.deleteLink(this.setje.begin.id,this.setje.end.id);
            }
            this.drawVerbindingen();
            this.setje = {'begin':null,'end':null};
        }
        else {
            console.warn('what happened here');
        }


    },
    //Functie om twee kaartjes te verbinden, of als ze al zijn verbonden
    //te verbreken
    drawVerbindingen: function() {
        //resetCanvas
        var canvas = document.getElementById('bord');
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        var cityMain = this.style.main;
        
        this.verbindingen.forEach(function(e,i) {
			//TODO: volgorde kaartjes bepalen
			var b = document.getElementById('event-'+e.begin);
			var end = document.getElementById('event-'+e.end);
        	if(parseFloat(end.attributes['data-x'].value) < parseFloat(b.attributes['data-x'].value)) {
				console.log('omdraaien')
                var endPoint = [parseFloat(b.attributes['data-x'].value) - 140,parseFloat(b.attributes['data-y'].value) - 105]
				var beginPoint = [parseFloat(end.attributes['data-x'].value) - 17,parseFloat(end.attributes['data-y'].value) - 17]
            
            
			}        
            else {
				var endPoint = [parseFloat(end.attributes['data-x'].value) - 140,parseFloat(end.attributes['data-y'].value) - 105]
                var beginPoint = [parseFloat(b.attributes['data-x'].value) - 17,parseFloat(b.attributes['data-y'].value) - 17]
            
            }
			/*if(parseFloat(end.attributes['data-x'].value) < parseFloat(b.attributes['data-x'].value)) {
				console.log('omdraaien')
                var endPoint = [parseFloat(b.attributes['data-x'].value) - 133,parseFloat(b.attributes['data-y'].value) - 30]
				var beginPoint = [parseFloat(end.attributes['data-x'].value) - 35,parseFloat(end.attributes['data-y'].value) - 98]
            
            
			}        
            else {
				var endPoint = [parseFloat(end.attributes['data-x'].value) - 133,parseFloat(end.attributes['data-y'].value) - 30]
                var beginPoint = [parseFloat(b.attributes['data-x'].value) - 35,parseFloat(b.attributes['data-y'].value) - 98]
            
            }*/
            context.beginPath();
            context.moveTo(beginPoint[0],beginPoint[1]);
            context.lineTo(endPoint[0],endPoint[1]);
            context.lineWidth = 5;
            context.strokeStyle = 'white';
            context.lineCap = 'round';
            context.stroke();
            context.beginPath();
            context.moveTo(beginPoint[0],beginPoint[1]);
            context.lineTo(endPoint[0],endPoint[1]);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(127, 133, 134, 0.8)';

            context.lineCap = 'round';
            context.stroke();
        });

        //this.stopWiebelen();
    },
    stopWiebelen: function(){
        this.setje = {'begin':null,'end':null};
        var kaartjes = document.getElementsByClassName('can-drop');
        for(var i = 0; i< kaartjes.length;i++){
            kaartjes[i].classList.remove('wiggle');
            kaartjes[i].classList.remove('first')
        }
    },
    //Functie om alles te resetten en naar het scorebord te gaan



    //hulpfunctie om de overige kaartjes te verwijderen
    _removeUnused: function() {
        this.verbinden =true; //Kaartjes-ronde is over, now we start verbinden
        this.speelkaarten = [];
        var allekaartjes  = document.getElementsByClassName('kaartje');
        //verwijder de kaartjes die niet op het speelbord liggen
        for(var i = 0; i< allekaartjes.length;i++){
            if(!allekaartjes[i].classList.contains('dropped'))
                allekaartjes[i].classList.add('hide');
            else this.speelkaarten.push(allekaartjes[i].id)
        }
    },

    _kaartjesChanged: function(){
        //Make sure that the kaartjes are all reset to their initial position
        if(this.beginSpel && this.kaartjes.length > 0) {

            this.beginSpel = false; //The game has started
        }
    },
    stampKaartje: function(e) {
        
        if(this.stamps < 5) {
        
        e.target.classList.add('stamped');
        this.stamps++
        }
    },
    //Function called when the slider reaches the end
    _doneChanged: function(){
        var instance = document.getElementById('instance');
        //Als de tijd verstreken is gaan we over op:
        if(this.done&& !this.verbinden) { // het verbinden van de kaartjes
            this.text = "INDIENEN";
            instance.setProgress(2);
            this._removeUnused();

            var self = this;
            interact('.draggable')
                .draggable({enabled:false})
                //Als het eerste kaartje wordt aangeraakt, gaan ze allemaal wiebelen tot dat
                //of hij weer wordt losgelaten
                //of een ander kaartje wordt aangeraakt
                //TODO: firefox registreerd de on down pas bij up
                .on('down',function(e){
                    if(e.ctrlKey) self.stampKaartje(e);
                    else self.selectKaartje(e);

                });
            this.sliderValue = 0; //Set the slider to 0
        }
        else if(this.done&&this.verbinden) { // scorebord
            //TODO: hier moet het scorebord komen
            this.verbinden = false;
            instance.setProgress(3);
            this.showScore()
            
        }
    },
    showScore: function() {
        document.getElementById('puzzelgame').style.display = 'none';
        document.getElementById('puzzelscore').style.display = 'block';
       
    },
    ready: function() {    
        this.stamps = 0;
        this.text = "VERBINDEN"
        this.beginSpel = true;  //boolean to make sure that we have started a new game
        this.verbinden = false; //boolean to state whether or not we're aan het verbinden
        this.start = true;
        this.speelkaarten = []; //Array with the chosen cards (empty at start)
        this.verbindingen =[];
        this.setje = {'begin':null,'end':null}; //Helper object to conenct kaartjes (empty at start)
        this.done= false; //boolean to alert that the slider reached the end of its run
        this.counter = 0; //the number of active kaartjes
        this.sliderValue=0;
        this.zindex = 1;
        
        var self = this;
        var w =  (window.innerWidth > 0) ? window.innerWidth : screen.width;
        this.width=w-550;
        var h =  (window.innerHeight > 0) ? window.innerHeight : screen.height;
        this.height=h-245;

        function dragMoveListener (event) {
            var target = event.target,
                // keep the dragged position in the data-x/data-y attributes
                x = (parseFloat(target.getAttribute('data-x')) || event.target.offsetLeft) + event.dx,
                y = (parseFloat(target.getAttribute('data-y')) || event.target.offsetTop) + event.dy;
            target.style.left = x+'px';
            target.style.top = y+'px';
            // update the position attributes
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        }

        window.dragMoveListener = dragMoveListener;

        // target elements with the "draggable" class
        interact('.draggable')
            .draggable({
                // enable inertial throwing
                inertia: true,
                // keep the element within the area of it's parent
                restrict: {
                    restriction: "parent",
                    endOnly: true,
                    elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                },
                // call this function on every dragmove event
                onmove: dragMoveListener
            })
            .on('down',function(e) {
              e.target.style.zIndex = self.zindex++
            })
            .on('up',function(e){
                //truukje om te zorgen dat je zonder multitouch wel kan werken
                
                if(e.shiftKey) return true;
                else self.stopWiebelen();

            });
        // Magic foobar to handle the dropping of kaartjes
        interact('.dropzone').dropzone({
            // only accept elements matching this CSS selector
            accept: '.kaartje',
            // Require a 75% element overlap for a drop to be possible
            overlap: 0.75,
            // listen for drop related events:
            ondropactivate: function (event) {
                // add active dropzone feedback
                event.target.classList.add('drop-active');
            },
            ondragenter: function (event) {
                if(self.counter>19) return false;

                var draggableElement = event.relatedTarget,
                    dropzoneElement = event.target;
                // feedback the possibility of a drop
                dropzoneElement.classList.add('drop-target');
                draggableElement.classList.add('can-drop');
            },
            ondragleave: function (event) {
                    if(event.relatedTarget.classList.contains('dropped')) {
                    //formerly dropped item, remove drom the counter
                    event.relatedTarget.classList.remove('dropped');
                     self.counter--;
                     
                     //Set the X&Y to '' and sync
                     var item = self.kaartjes[event.relatedTarget.id.split('-')[1]];
                     item.data('x','').data('y','').sync();
                }
                // remove the drop feedback style
                event.target.classList.remove('drop-target');
                event.relatedTarget.classList.remove('can-drop');
            },
            ondrop: function (event) {
                //We're at 20 kaartjes, no more are allowed (unless it is a currently dropepd one)
                if(self.counter>19&&!event.relatedTarget.classList.contains('dropped')) {
                    return false;
                }
                if(!event.relatedTarget.classList.contains('dropped')) self.counter++;
                //Mark the kaartje as dropped and increase the counter
                event.relatedTarget.classList.add('dropped');

                
                //calculate the X and Y score
                var kaartjeX = Math.round((event.relatedTarget.offsetLeft -150 + 68 - 1)/event.target.width*100);
                var kaartjeY = Math.round((event.target.height - (event.relatedTarget.offsetTop -110 + 53 - 1))/event.target.height *50+50);

                //TODO: is dit niet buggy??
                var item = self.kaartjes[event.relatedTarget.id.split('-')[1]];

                //Set the X&Y score per kaartje and sync using cow.
                item.data('x',kaartjeX).data('y',kaartjeY).sync();
            },
            ondropdeactivate: function (event) {
                //Canvas isn't a droptarget anymore; clean up
                event.target.classList.remove('drop-active');
                event.target.classList.remove('drop-target');
            }
        });
    }
  });
</script>
