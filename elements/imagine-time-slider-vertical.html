<link rel="import"
      href="../bower_components/polymer/polymer.html">
 
<link rel="import" href="../bower_components/paper-styles/paper-styles.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-behaviors/iron-control-state.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">

 
<dom-module id="imagine-time-slider-vertical">
  <style>
:host {
    display: inline-block;
    height: 100%;
    cursor: default;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
:host #sliderBar::shadow #activeProgress , :host #sliderBar::shadow  #progressContainer.paper-progress{
  background-color: rgba(0,0,0,0);
}
:host(:focus) {
  outline: none;
}
#imagineContainer {
    border: solid 1px #3A3335;
    background-color: #fcfcfc;
    transition-property:  background, border;
    transition-duration: 30s;
     transition-timing-function: cubic-bezier(0,1,0,1);
     height: 100%;

}
 #imagineContainer.urgent {
     border: solid 1px #4CC0D0;
     background-color: var(--paper-slider-knob-color, --google-blue-700);
     
}


#sliderContainer {
  position: relative;
  width: 48px;
  height: calc(100% - 126px);
   background: linear-gradient(to bottom, rgba(252,252,252,1) 0%,rgba(252,252,252,1) 80%,rgba(252,252,252,0) 100%); 
   
}
.bar-container {
  position: absolute;
  top: 0;
  left: 0px;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
#sliderBar {
  position: absolute;
  top: 0px;
  left: 0;
  height:100%;
  width:  52px;
  padding: 8px 0;
  margin: -8px 0;
}
#sliderKnob {
  @apply(--layout-center-justified);
  @apply(--layout-center);
  @apply(--layout-horizontal);
  position: absolute;
  left: -36px;
  text-align: center;
  width: 120px;
  margin-top: 42px;
  transform: rotate(90deg);
  -moz-box-shadow:    1px 1px 2px 0px #3A3335;
  -webkit-box-shadow:  1px 1px 2px 0px #3A3335;
  box-shadow:         1px 1px 2px 0px #3A3335;
}
#sliderKnob:focus {
  outline: none;
}
#sliderKnob.dragging {
  transition: none;
}
#sliderKnobInner {
  padding: 10px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  background-color: var(--paper-slider-knob-color, --google-blue-700);
  transition-property: height, width, background-color, border, left;
  transition-duration: 0.1s;
  transition-timing-function: ease;
  height: 40px;
  width: 120px;
  text-align: center;
}
.expand:not(.pin) > #sliderKnob > #sliderKnobInner {
  
  color: white;
 transition-property:  margin;
  transition-duration: 0.1s;
  transition-timing-function: ease;
  -moz-box-shadow:    2px 2px 5px 0px #3A3335;
  -webkit-box-shadow:  2px 2px 5px 0px #3A3335;
  box-shadow:         2px 2px 5px 0px #3A3335;
}
#sliderKnob.tap {
 transition-property:  left;
  transition-duration: 0.1s;
  transition-timing-function: ease;
  }
  

.tap > #sliderKnob  {
  left: 10% !important;
  
}



#sliderKnobInner::before,
#sliderKnobInner::after {
  transition: -webkit-transform .2s ease, background-color .18s ease;
  transition: transform .2s ease, background-color .18s ease;
}




  </style>
  <template>
  <audio id="clock" src="clock.mp3"></audio>
    <!-- local DOM for your element -->
    <div id="imagineContainer"  class$="[[_getClassNames( urgent)]]" >
     <div id="sliderContainer" class$="[[_getClassNames( expand, dragging,urgent)]]">
      <div class="bar-container">
        <paper-progress id="sliderBar" aria-hidden="true" min="[[min]]" max="[[max]]"value="[[immediateValue]]"
          on-up="_resetKnob" on-track="_onTrack" done="[[done]]"></paper-progress>
      </div>


      <div id="sliderKnob"   on-down="_knobdown" on-up="_resetKnob"
        on-track="_onTrack"       
        center-justified center horizontal layout>

        <div id="sliderKnobInner" >{{text}}</div>
      </div>
    </div>
    </div>
  </template>
</dom-module>

<script>
  // register a new element called proto-element
  Polymer({
    
    is: "imagine-time-slider-vertical",
     behaviors: [
      Polymer.IronRangeBehavior,
      Polymer.IronControlState
    ],
    properties: {
      /**
       * If true, the slider thumb snaps to tick marks evenly spaced based
       * on the `step` property value.
       */
      snaps: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * If true, a pin with numeric value label is shown when the slider thumb
       * is pressed.  Use for settings for which users need to know the exact
       * value of the setting.
       */
      pin: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * The number that represents the current secondary progress.
       */
      secondaryProgress: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_secondaryProgressChanged'
      },
      /**
       * If true, an input is shown and user can use it to set the slider value.
       */
      editable: {
        type: Boolean,
        value: false
      },
      /**
       * The immediate value of the slider.  This value is updated while the user
       * is dragging the slider.
       */
      immediateValue: {
        type: Number,
        value: 0,
        readOnly: true
      },
      /**
       * The maximum number of markers
       */
      maxMarkers: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_maxMarkersChanged'
      },
      /**
       * If true, the knob is expanded
       */
      expand: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      urgent: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      done: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * True when the user is dragging the slider.
       */
      dragging: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      transiting: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      markers: {
        readOnly: true,
        value: []
      },
      start: {
        type: Boolean,
        value: false        
      },
      text: {
        type: String,
        value: 'VERBIND'
      }
    },
    observers: [
      '_updateKnob(value, min, max, snaps, step)',
      '_minChanged(min)',
      '_maxChanged(max)',
      '_valueChanged(value)',
      '_urgentChanged(value)',
      '_immediateValueChanged(immediateValue)',
      '_startChanged(start)'
    ],
    ready: function() {
      // issue polymer/polymer#1305
      this.async(function() {
        this._updateKnob(this.value);
        this._updateInputValue();
      }, 1);
  
        
    },
    /**
     * Increases value by `step` but not above `max`.
     * @method increment
     */
    increment: function() {
      this.value = this._clampValue(this.value + this.step);      
    },
    /**
     * Decreases value by `step` but not below `min`.
     * @method decrement
     */
    decrement: function() {
      this.value = this._clampValue(this.value - this.step);
    },
    _startChanged: function(e) {    
        if(e) {            
            this.value = 0;
            var self = this;
            this.interval = setInterval(function(){    
                if(!self.dragging)
                self.increment()
            },1000)
        }
        else {
            this.done = false;
            
            clearInterval(this.interval);
        }
    },
    _updateKnob: function(value) {
      this._positionKnob(this._calcRatio(value));
    },
    _minChanged: function() {
      this.setAttribute('aria-valuemin', this.min);
    },
    _maxChanged: function() {
      this.setAttribute('aria-valuemax', this.max);
    },
    _urgentChanged: function(){    
    
        if(this.urgent) {
        
           document.getElementById('clock').play()
        }
        else {
           document.getElementById('clock')?document.getElementById('clock').pause():null;
        }
    },
    _valueChanged: function() {
      this._setDone(false);
      this.setAttribute('aria-valuenow', this.value);
      this.fire('value-change');
      var ratio = this._calcRatio(this.value)
      if(ratio>0.9) {       
        this._setUrgent(true);
        if(ratio===1) {
        this._setUrgent(false);
         this._setDone(true);
        }
      }
      else this._setUrgent(false);
    },
    _immediateValueChanged: function() {
      if (this.dragging) {
        this.fire('immediate-value-change');
      } else {
        this.value = this.immediateValue;
      }
      this._updateInputValue();
    },
    _secondaryProgressChanged: function() {
      this.secondaryProgress = this._clampValue(this.secondaryProgress);
    },
    _updateInputValue: function() {
      if (this.editable) {
        this.$$('#input').value = this.immediateValue;
      }
    },
    _expandKnob: function() {
      this._setExpand(true);
    },
    _resetKnob: function() {
      this._expandJob && this._expandJob.stop();
      this._setExpand(false);
    },
    _positionKnob: function(ratio) {
      this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)) || 0);
      this._setRatio(this.snaps ? this._calcRatio(this.immediateValue) : ratio);
      this.$.sliderKnob.style.top = this.ratio * 100 + '%';
    },
    _inputChange: function() {
      this.value = this.$$('#input').value;
      this.fire('change');
    },
    _calcKnobPosition: function(ratio) {
      return (this.max - this.min) * ratio + this.min;
    },
    _onTrack: function(event) {
      switch (event.detail.state) {
        case 'start':
          this._trackStart(event);
          break;
        case 'track':
          this._trackY(event);
          break;
        case 'end':
          this._trackEnd(event);
          break;
      }
    },
    _trackStart: function(event) {
      this._h = this.$.sliderBar.offsetHeight;
      this._y = this.ratio * this._h;
      this._starty = this._y || 0;
      this._miny = - this._starty;
      this._maxy = this._h - this._starty;
      this.$.sliderKnob.classList.add('dragging');
      this._setDragging(true);
    },
    _trackY: function(event) {
    if(event.detail.dy<0) return false;
      var y = Math.min(this._maxy, Math.max(this._miny, event.detail.dy));
      this._y = this._starty + y;
      this._setImmediateValue(this._calcStep(
          this._calcKnobPosition(this._y / this._h)) || 0);
      var s =  this.$.sliderKnob.style;
      s.transform = s.webkitTransform = 'rotate(90deg) translate3d( ' + (this.snaps ?
          (this._calcRatio(this.immediateValue) * this._h) - this._starty : y) + 'px, 0, 0)';
    },
    _trackEnd: function() {
      var s =  this.$.sliderKnob.style;
      s.transform = s.webkitTransform = '';
      this.$.sliderKnob.classList.remove('dragging');
      this._setDragging(false);
      this._resetKnob();
      this.value = this.immediateValue;
      this.fire('change');
    },
    _knobdown: function(event) {
      event.detail.sourceEvent.preventDefault();
      this._expandKnob();
    },
    _bardown: function(event) {
      event.preventDefault();
      this._setTransiting(true);
      this._h = this.$.sliderBar.offsetHeight;
      var rect = this.$.sliderBar.getBoundingClientRect();
      var ratio = (event.detail.y - rect.top) / this._h;
      this._positionKnob(ratio);
      this._expandJob = this.debounce(this._expandJob, this._expandKnob, 60);
      this.async(function() {
        this.fire('change');
      });
      event.detail.sourceEvent.preventDefault();
    },
    _knobTransitionEnd: function(event) {
      if (event.target === this.$.sliderKnob) {
        this._setTransiting(false);
      }
    },
    _maxMarkersChanged: function(maxMarkers) {
      var l = (this.max - this.min) / this.step;
      if (!this.snaps && l > maxMarkers) {
        this._setMarkers([]);
      } else {
        this._setMarkers(new Array(l));
      }
    },
    _getClassNames: function() {
      var classes = {};
     
      classes['urgent'] = this.urgent;
   
      classes['expand'] = this.expand;
      classes['dragging'] = this.dragging;
      return Object.keys(classes).filter(
        function(className) {
          return classes[className];
        }).join(' ');
    },
    _incrementKey: function(ev, keys) {
      if (keys.key === 'end') {
        this.value = this.max;
      } else {
        this.increment();
      }
      this.fire('change');
    },
    _decrementKey: function(ev, keys) {
      if (keys.key === 'home') {
        this.value = this.min;
      } else {
        this.decrement();
      }
      this.fire('change');
    }
    
  });
</script>